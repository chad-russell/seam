extern print_string(len: i64, ptr: *i8) i64;

fn print_str(s: *string) i64 {
    print_string(s.len, s.buf);
    return 0;
}

// macro mac_id(t: Tokens) Tokens {
//     print_str(&"hello");
//     return t;
// }

// mac_id! {
//     extern print_int(i: i64) i64;
// }

// enum Token {
//     LParen: struct{},
//     RParen: struct{},
//     LCurly: struct{},
//     RCurly: struct{},
//     LSquare: struct{},
//     RSquare: struct{},
//     Semicolon: struct{},
//     Colon: struct{},
//     Bang: struct{},
//     Backslash: struct{},
//     Dot: struct{},
//     Asterisk: struct{},
//     Eq: struct{},
//     Comma: struct{},
//     Struct: struct{},
//     Enum: struct{},
//     Fn: struct{},
//     Extern: struct{},
//     If: struct{},
//     Else: struct{},
//     True: struct{},
//     False: struct{},
//     I8: struct{},
//     I16: struct{},
//     I32: struct{},
//     I64: struct{},
//     Ampersand: struct{},
//     Type_: struct{},
//     Caret: struct{},
//     Uninit: struct{},
//     Symbol: string,
//     IntegerLiteral: i64,
//     FloatLiteral: f64,
//     StringLiteral: string,
// }

enum Ty {
    I8: struct{},
    I32: struct{},
    I64: struct{},
    F32: struct{},
    F64: struct{},
    String: struct{},
    Pointer: *Ty,
    Array: *Ty,
    Struct: []struct {
        name: string,
        type: Ty,
    },
    Enum: []struct {
        name: string,
        type: Ty,
    },
    Func: struct {
        input_types: []Ty,
        return_type: *Ty,
    },
    Hack: []Ty,
}

fn main() i64 {
    // let a: i64 = 12;
    // let b: i32 = 12;
    // a = b;
    // return a;

    let t: Ty = {
        Struct: []{
            {
                name: "foo",
                type: { I64: {} }
            },
            {
                name: "bar",
                type: { I32: {} }
            }
        }
    };

    print_str(&t.Struct[1].name);

    return 0;
}

// fn old_tests() i64 {
//     // return poly_call(id, 15);
//     // return poly_call(poly_id, 99);
//     // return poly_omg(poly_call, poly_id, 10);
//     // return test_poly1();

//     // return omg(call, id, 10);
//     // return call(id, 10);

//     // return test_fn_ptr();
//     // return cpi_test();
//     // return baz();
//     // return bar();
//     // return test_load_param();

//     return 0;
// }

// struct Point {
//     x: i64,
//     y: i64,
// }

// struct Line {
//     start: *Point,
//     end: *Point,
// }

// struct Foo {
//     value: i64,
//     bar: *Bar,
// }

// struct Bar {
//     value: i64,
//     baz: *Baz,
// }

// struct Baz {
//     value: i64,
//     qux: *Qux,
// }

// struct Qux {
//     value: **i64,
// }

// struct Poly<T: Type> {
//     val: T,
// }

// fn test_poly1() i64 {
//     let p: Point = {x: 3, y: 4};
//     // return get_y(&p);
//     return poly_get_y(&p);
// }

// fn test_poly2() i64 {
//     let a: Poly = { val: 5 };
//     let b: Poly = { val: true };
//     return a.val;
// }

// fn test_poly3() i64 {
//     let a = poly_id(5);
//     let b = poly_id(true);
//     return a;
// }

// fn get_x(p: *Point) i64 {
//     let hack_p = p;
//     return hack_p.x;
// }

// fn get_y(p: *Point) i64 {
//     let hack_p = p;
//     return hack_p.y;
// }

// fn poly_get_y<T: Type>(p: *T) i64 {
//     let hack_p = p;
//     let p2 = ^hack_p;
//     return p2.y;
// }

// fn id(n: i64) i64 {
//     return n;
// }

// fn poly_id<P: Type>(x: P) P {
//     return x;
// }

// fn call(f: fn(n: i64) i64, val: i64) i64 {
//     return f(val);
// }

// fn poly_call<T: Type, R: Type>(f: fn(n: T) R, val: T) R {
//     return f(val);
// }

// fn omg(g: fn(f1: fn(n1: i64) i64, val1: i64) i64, 
//        f: fn(n: i64) i64, 
//        val: i64) i64 {
//     return g(f, val);
// }

// fn poly_omg<P: Type>(
//     g: fn(f1: fn(n1: P) P, val1: P) P, 
//     f: fn(n: P) P, 
//     val: P
// ) P {
//     return g(f, val);
// }

// fn test_fn_ptr() i64 {
//     let f: fn(n: i64) i64 = ---;
//     f = id;
//     return f(2);
// }

// fn cpi_test() i64 {
//     let foo: Foo = ---;
//     let bar: Bar = ---;
//     let baz: Baz = ---;
//     let qux: Qux = ---;

//     foo.value = 111;
//     bar.value = 222;
//     baz.value = 333;
//     qux.value = &&444;

//     baz.qux = &qux;
//     bar.baz = &baz;
//     foo.bar = &bar;

//     ^bar.baz.qux.value = &7;

//     // assert(3 == ^^foo.bar.baz.qux.value);
//     // assert(3 == ^^bar.baz.qux.value);
//     // assert(3 == ^^baz.qux.value);
//     // assert(3 == ^^qux.value);

//     return ^&^^^&&^(^^^&&&foo.bar.baz).qux.value;
// }
    
// fn test_load_param() i64 {
//     return load_wrapper(&&10);
// }

// fn load_wrapper(n: **i64) i64 {
//     return ^^n;
// }

// fn bar() i64 {
//     let p: Point = ---;

//     let l2: Line = ---;
//     l2.start = &p;

//     let l = &l2;

//     let ppp = &l.start;
//     let pp = ^ppp;
//     pp.y = 123;

//     // let ppp2 = &l.start;
//     // (^ppp2).y = 120;

//     // let ps: *Point = l.start;
//     // ps.y = 300;

//     // l.start.y = 123;

//     return p.y;
// }

// fn baz() i64 {
//     let p: Point = ---;
//     let pp = &p;
//     let ppp = &pp;

//     let p2: Point = ---;
//     p2.x = 3;
//     p2.y = 8;
//     let pp2 = &p2;

//     ^^ppp = ^pp2;
//     return p.y;
// }
